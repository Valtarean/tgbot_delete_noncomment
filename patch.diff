From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Copilot <copilot@example.com>
Date: Fri, 26 Dec 2025 00:00:00 +0000
Subject: [PATCH] Refactor: pydantic settings, split modules, add tests, CI, Dockerfile, README

---
 bot.py                                           | 313 ++++++++++++++++++++++++++++++++
 settings.py                                      |  29 +++
 analyzer.py                                      | 116 ++++++++++
 db.py                                            |  82 ++++++++
 warning_manager.py                               | 147 ++++++++++++++
 notifier.py                                      |  86 ++++++++
 requirements.txt                                 |  10 +
 README.md                                        | 120 ++++++++++
 .env.example                                     |  25 +
 .github/workflows/ci.yml                         |  52 ++++
 Dockerfile                                       |  18 +
 .gitignore                                       |  10 +
 docs/systemd/tgbot.service.example               |  12 +
 tests/test_analyzer.py                           |  58 +++
 tests/test_warning_manager.py                    | 114 ++++++++
 15 files changed, 1292 insertions(+)
 create mode 100644 bot.py
 create mode 100644 settings.py
 create mode 100644 analyzer.py
 create mode 100644 db.py
 create mode 100644 warning_manager.py
 create mode 100644 notifier.py
 create mode 100644 requirements.txt
 create mode 100644 README.md
 create mode 100644 .env.example
 create mode 100644 .github/workflows/ci.yml
 create mode 100644 Dockerfile
 create mode 100644 .gitignore
 create mode 100644 docs/systemd/tgbot.service.example
 create mode 100644 tests/test_analyzer.py
 create mode 100644 tests/test_warning_manager.py
--- /dev/null
+++ b/bot.py
@@ -0,0 +1,313 @@
+#!/usr/bin/env python3
+import asyncio
+import logging
+import signal
+import sys
+from typing import Optional, Set, List
+
+from aiogram import Bot, Dispatcher, F
+from aiogram.types import Message
+from aiogram.enums import ChatType
+from aiogram.filters import Command
+
+from settings import Settings
+from analyzer import MessageAnalyzer
+from notifier import NotificationService
+from warning_manager import WarningManager
+from db import init_db
+
+logger = logging.getLogger(__name__)
+logging.basicConfig(
+    level=logging.INFO,
+    format="%(asctime)s - %(levelname)s - %(name)s - %(message)s",
+)
+
+
+class DiscussionBot:
+    def __init__(self, settings: Settings):
+        self.settings = settings
+        self.bot = Bot(token=self.settings.bot_token)
+        self.dp = Dispatcher()
+        self.analyzer = MessageAnalyzer(settings)
+        self.notifier = NotificationService(self.bot, settings.admin_id, settings.group_id)
+        self.warning_manager = WarningManager(
+            cooldown_seconds=self.settings.warning_cooldown,
+            db_path=self.settings.db_path,
+        )
+        self._admin_cache: Set[int] = set()
+        self._admin_cache_time = None
+        self._admin_cache_ttl = self.settings.admin_cache_ttl_minutes
+        self._tasks: Set[asyncio.Task] = set()
+        self._register_handlers()
+
+    def _register_handlers(self) -> None:
+        self.dp.message.register(
+            self._handle_group_message,
+            F.chat.id == self.settings.group_id,
+        )
+        self.dp.message.register(self._cmd_status, Command("status"))
+        self.dp.message.register(self._cmd_test, Command("test"))
+        self.dp.message.register(self._cmd_debug, Command("debug_chain"))
+        self.dp.message.register(self._cmd_warnings, Command("warnings"))
+        self.dp.message.register(
+            self._handle_private_message, F.chat.type == ChatType.PRIVATE
+        )
+
+    async def _get_admin_user_ids_cached(self):
+        # Minimal cache: refresh every admin_cache_ttl_minutes
+        from datetime import datetime, timezone
+
+        now = datetime.now(timezone.utc)
+        if self._admin_cache_time and (now - self._admin_cache_time).total_seconds() < (
+            self._admin_cache_ttl * 60
+        ):
+            return self._admin_cache
+        try:
+            admins = await self.bot.get_chat_administrators(chat_id=self.settings.group_id)
+            self._admin_cache = {admin.user.id for admin in admins if admin.user}
+            self._admin_cache_time = now
+            logger.debug("Admin cache refreshed: %d admins", len(self._admin_cache))
+            return self._admin_cache
+        except Exception:
+            logger.exception("Failed to refresh admin list")
+            return self._admin_cache
+
+    def _create_task(self, coro: asyncio.coroutine) -> asyncio.Task:
+        task = asyncio.create_task(coro)
+        self._tasks.add(task)
+
+        def _on_done(t: asyncio.Task):
+            self._tasks.discard(t)
+            if t.cancelled():
+                logger.debug("Background task cancelled")
+            elif t.exception():
+                logger.exception("Background task exception", exc_info=t.exception())
+
+        task.add_done_callback(_on_done)
+        return task
+
+    async def _schedule_deletion(self, chat_id: int, message_ids: List[int], delay: int):
+        try:
+            await asyncio.sleep(delay)
+            for mid in message_ids:
+                try:
+                    await self.bot.delete_message(chat_id=chat_id, message_id=mid)
+                    logger.debug("Deleted message %s", mid)
+                except Exception:
+                    logger.debug("Failed to delete message %s", mid, exc_info=True)
+        except asyncio.CancelledError:
+            logger.info("Deletion task cancelled")
+            raise
+        except Exception:
+            logger.exception("Error in deletion task")
+
+    async def _handle_group_message(self, message: Message) -> None:
+        # Ignore admins
+        if message.from_user:
+            admin_ids = await self._get_admin_user_ids_cached()
+            if message.from_user.id in admin_ids:
+                logger.debug("Message from admin %s skipped", message.from_user.id)
+                return
+
+        full_text = (message.text or message.caption or "").strip()
+        if full_text.startswith("/"):
+            return
+
+        if self._is_service_message(message):
+            logger.debug("Service message ignored: %s", getattr(message, "message_id", None))
+            return
+
+        is_in_thread = await self.analyzer.is_in_discussion_thread(message)
+        logger.info(
+            "New group message id=%s user=%s in_thread=%s",
+            getattr(message, "message_id", None),
+            getattr(getattr(message, "from_user", None), "id", None),
+            is_in_thread,
+        )
+
+        if not is_in_thread:
+            warning_id = await self.warning_manager.send_warning(self.bot, message)
+            await self.notifier.notify_off_topic_message(message)
+
+            to_delete = [message.message_id]
+            if warning_id:
+                to_delete.append(warning_id)
+
+            self._create_task(
+                self._schedule_deletion(
+                    chat_id=message.chat.id,
+                    message_ids=to_delete,
+                    delay=self.settings.auto_delete_delay,
+                )
+            )
+        else:
+            logger.debug("Message is in discussion thread or from channel; ignored")
+
+    @staticmethod
+    def _is_service_message(message: Message) -> bool:
+        service_fields = [
+            "new_chat_members",
+            "left_chat_member",
+            "new_chat_title",
+            "new_chat_photo",
+            "delete_chat_photo",
+            "group_chat_created",
+            "supergroup_chat_created",
+            "channel_chat_created",
+            "migrate_to_chat_id",
+            "migrate_from_chat_id",
+            "pinned_message",
+            "invoice",
+            "successful_payment",
+            "video_chat_started",
+            "video_chat_ended",
+            "video_chat_scheduled",
+            "video_chat_participants_invited",
+            "web_app_data",
+            "forum_topic_created",
+            "forum_topic_edited",
+            "forum_topic_closed",
+            "forum_topic_reopened",
+            "general_forum_topic_hidden",
+            "general_forum_topic_unhidden",
+            "write_access_allowed",
+        ]
+        return any(getattr(message, f, None) is not None for f in service_fields)
+
+    async def _cmd_status(self, message: Message) -> None:
+        if not message.from_user or message.from_user.id != self.settings.admin_id:
+            return
+        await message.answer(
+            "üü¢ <b>–°—Ç–∞—Ç—É—Å –±–æ—Ç–∞</b>\n\n"
+            f"üìä –ì—Ä—É–ø–ø–∞: <code>{self.settings.group_id}</code>\n"
+            f"üì∫ –ö–∞–Ω–∞–ª: <code>{self.settings.channel_id}</code>\n"
+            f"üë§ –ê–¥–º–∏–Ω: <code>{self.settings.admin_id}</code>\n"
+            f"‚è± –£–¥–∞–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑: <code>{self.settings.auto_delete_delay}s</code>",
+            parse_mode="HTML",
+        )
+
+    async def _cmd_test(self, message: Message) -> None:
+        await message.answer(
+            "‚úÖ <b>–ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç!</b>\n\n"
+            "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã –∏–≥–Ω–æ—Ä–∏—Ä—É—é—Ç—Å—è.\n"
+            "–°–æ–æ–±—â–µ–Ω–∏—è –≤–Ω–µ –≤–µ—Ç–æ–∫ —É–¥–∞–ª—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.",
+            parse_mode="HTML",
+        )
+
+    async def _cmd_debug(self, message: Message) -> None:
+        if not message.from_user or message.from_user.id != self.settings.admin_id:
+            return
+        if not message.reply_to_message:
+            await message.answer("‚ùå –û—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ü–µ–ø–æ—á–∫–∏.")
+            return
+        chain_info = await self.analyzer.analyze_chain(message.reply_to_message)
+        await message.answer(f"<pre>{chain_info}</pre>", parse_mode="HTML")
+
+    async def _cmd_warnings(self, message: Message) -> None:
+        if not message.from_user or message.from_user.id != self.settings.admin_id:
+            return
+        stats = await self.warning_manager.format_stats()
+        await message.answer(stats, parse_mode="HTML")
+
+    async def _handle_private_message(self, message: Message) -> None:
+        await message.answer(
+            "üëã –ü—Ä–∏–≤–µ—Ç!\n\n"
+            "–Ø –æ—Ç—Å–ª–µ–∂–∏–≤–∞—é —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –≥—Ä—É–ø–ø–µ –æ–±—Å—É–∂–¥–µ–Ω–∏—è –∫–∞–Ω–∞–ª–∞.\n"
+            "–ö–æ–º–∞–Ω–¥—ã: /status /test /debug_chain /warnings"
+        )
+
+    async def start(self) -> None:
+        logger.info("Starting bot...")
+        await self.notifier.send_startup()
+
+        loop = asyncio.get_running_loop()
+        for sig in (signal.SIGINT, signal.SIGTERM):
+            try:
+                loop.add_signal_handler(sig, lambda: asyncio.create_task(self._shutdown()))
+            except NotImplementedError:
+                # Windows may raise
+                pass
+
+        try:
+            await self.dp.start_polling(self.bot)
+        except Exception:
+            logger.exception("Polling error")
+        finally:
+            await self._shutdown()
+
+    async def _shutdown(self) -> None:
+        logger.info("Shutting down...")
+        # cancel background tasks
+        for t in list(self._tasks):
+            t.cancel()
+        await asyncio.sleep(0.1)
+        await self.notifier.send_shutdown()
+        try:
+            await self.bot.session.close()
+        except Exception:
+            logger.exception("Error closing bot session")
+        logger.info("Shutdown complete")
+
+
+async def main():
+    try:
+        settings = Settings()
+    except Exception as exc:
+        logger.critical("Settings error: %s", exc)
+        sys.exit(1)
+
+    # init DB for warnings
+    await init_db(settings.db_path)
+
+    bot = DiscussionBot(settings)
+    await bot.start()
+
+
+if __name__ == "__main__":
+    asyncio.run(main())
+
--- /dev/null
+++ b/settings.py
@@ -0,0 +1,29 @@
+from pydantic import BaseSettings, Field
+
+
+class Settings(BaseSettings):
+    bot_token: str = Field(..., env="BOT_TOKEN")
+    admin_id: int = Field(..., env="ADMIN_ID")
+    group_id: int = Field(..., env="GROUP_ID")
+    channel_id: int = Field(..., env="CHANNEL_ID")
+
+    auto_delete_delay: int = Field(10, env="AUTO_DELETE_DELAY")
+    warning_cooldown: int = Field(180, env="WARNING_COOLDOWN")
+    admin_cache_ttl_minutes: int = Field(600, env="ADMIN_CACHE_TTL_MINUTES")
+    max_chain_depth: int = Field(20, env="MAX_CHAIN_DEPTH")
+
+    # Persistence
+    db_path: str = Field("data/bot.sqlite3", env="DB_PATH")
+
+    class Config:
+        env_file = ".env"
+        env_file_encoding = "utf-8"
+
--- /dev/null
+++ b/analyzer.py
@@ -0,0 +1,116 @@
+from typing import Optional
+from aiogram.types import Message
+
+TELEGRAM_SERVICE_ID = 777000
+
+
+class MessageAnalyzer:
+    def __init__(self, settings):
+        self.settings = settings
+
+    def is_channel_post(self, message: Message) -> bool:
+        # robust checks for channel-origin or forwarded-from-channel
+        try:
+            if getattr(message, "sender_chat", None):
+                return True
+            if message.from_user and getattr(message.from_user, "id", None) == TELEGRAM_SERVICE_ID:
+                return True
+            if getattr(message, "is_automatic_forward", False):
+                return True
+            fchat = getattr(message, "forward_from_chat", None)
+            if fchat and getattr(fchat, "id", None) == self.settings.channel_id:
+                return True
+            origin = getattr(message, "forward_origin", None)
+            if origin and getattr(origin, "chat", None) and getattr(origin.chat, "id", None) == self.settings.channel_id:
+                return True
+        except Exception:
+            # be permissive in case of unexpected structure
+            return False
+        return False
+
+    async def is_in_discussion_thread(self, message: Message) -> bool:
+        if self.is_channel_post(message):
+            return True
+        if getattr(message, "message_thread_id", None):
+            return True
+        return await self._check_reply_chain(message, depth=0)
+
+    async def _check_reply_chain(self, message: Message, depth: int) -> bool:
+        if depth >= self.settings.max_chain_depth:
+            return False
+        reply = getattr(message, "reply_to_message", None)
+        if not reply:
+            return False
+        if self.is_channel_post(reply):
+            return True
+        if getattr(reply, "message_thread_id", None):
+            return True
+        if getattr(reply, "reply_to_message", None):
+            return await self._check_reply_chain(reply, depth + 1)
+        return False
+
+    async def analyze_chain(self, message: Message, max_depth: int = 10) -> str:
+        return await self._analyze_recursive(message, 0, max_depth)
+
+    async def _analyze_recursive(self, message: Message, depth: int, max_depth: int) -> str:
+        if depth >= max_depth:
+            return f"{'  '*depth}‚ö° reached max depth"
+        indent = "  " * depth
+        parts = []
+        thread_info = f" [thread: {getattr(message, 'message_thread_id', '')}]" if getattr(message, "message_thread_id", None) else ""
+        user_info = f" from {getattr(getattr(message, 'from_user', None), 'id', 'N/A')}"
+        parts.append(f"{indent}Level {depth}: id {getattr(message, 'message_id', 'N/A')}{user_info}{thread_info}")
+        if self.is_channel_post(message):
+            parts.append(f"{indent}   CHANNEL POST")
+        if getattr(message, "reply_to_message", None):
+            reply = message.reply_to_message
+            parts.append(f"{indent}   reply to: {getattr(reply, 'message_id', 'N/A')}")
+            parts.append(await self._analyze_recursive(reply, depth + 1, max_depth))
+        else:
+            parts.append(f"{indent}   END")
+        return "\n".join(parts)
+
--- /dev/null
+++ b/db.py
@@ -0,0 +1,82 @@
+import aiosqlite
+import asyncio
+from pathlib import Path
+
+DB_INIT_SQL = """
+CREATE TABLE IF NOT EXISTS warnings (
+    user_id INTEGER PRIMARY KEY,
+    last_warning_ts INTEGER
+);
+"""
+
+_db_lock = asyncio.Lock()
+
+
+async def init_db(path: str = "data/bot.sqlite3"):
+    Path(path).parent.mkdir(parents=True, exist_ok=True)
+    async with _db_lock:
+        async with aiosqlite.connect(path) as db:
+            await db.execute(DB_INIT_SQL)
+            await db.commit()
+
+
+async def set_last_warning(db_path: str, user_id: int, ts: int):
+    async with aiosqlite.connect(db_path) as db:
+        await db.execute(
+            "INSERT INTO warnings(user_id, last_warning_ts) VALUES (?, ?) "
+            "ON CONFLICT(user_id) DO UPDATE SET last_warning_ts=excluded.last_warning_ts",
+            (user_id, ts),
+        )
+        await db.commit()
+
+
+async def get_last_warning(db_path: str, user_id: int):
+    async with aiosqlite.connect(db_path) as db:
+        cur = await db.execute("SELECT last_warning_ts FROM warnings WHERE user_id = ?", (user_id,))
+        row = await cur.fetchone()
+        return row[0] if row else None
+
+
+async def get_all_warnings(db_path: str):
+    async with aiosqlite.connect(db_path) as db:
+        cur = await db.execute("SELECT user_id, last_warning_ts FROM warnings")
+        rows = await cur.fetchall()
+        return {r[0]: r[1] for r in rows}
+
--- /dev/null
+++ b/warning_manager.py
@@ -0,0 +1,147 @@
+from datetime import datetime, timezone
+from typing import Optional, Dict
+import html
+import logging
+
+from aiogram import Bot
+from aiogram.types import Message
+
+from db import set_last_warning, get_last_warning, get_all_warnings
+
+logger = logging.getLogger(__name__)
+
+
+class WarningManager:
+    def __init__(self, cooldown_seconds: int = 180, db_path: str = "data/bot.sqlite3"):
+        self.cooldown_seconds = cooldown_seconds
+        self.db_path = db_path
+        # in-memory cache to reduce DB hits (user_id -> timestamp int)
+        self._cache: Dict[int, int] = {}
+
+    async def _load_cache(self):
+        try:
+            data = await get_all_warnings(self.db_path)
+            self._cache = data
+        except Exception:
+            logger.exception("Failed to load warnings cache")
+
+    async def can_warn(self, user_id: int) -> bool:
+        if not self._cache:
+            await self._load_cache()
+        ts = self._cache.get(user_id)
+        if not ts:
+            return True
+        now = int(datetime.now(timezone.utc).timestamp())
+        return (now - ts) >= self.cooldown_seconds
+
+    async def record_warning(self, user_id: int) -> None:
+        now = int(datetime.now(timezone.utc).timestamp())
+        await set_last_warning(self.db_path, user_id, now)
+        self._cache[user_id] = now
+
+    async def get_time_until_next_warning(self, user_id: int) -> Optional[int]:
+        if not self._cache:
+            await self._load_cache()
+        ts = self._cache.get(user_id)
+        if not ts:
+            return None
+        now = int(datetime.now(timezone.utc).timestamp())
+        remaining = self.cooldown_seconds - (now - ts)
+        return max(0, remaining) if remaining > 0 else None
+
+    async def send_warning(self, bot: Bot, message: Message) -> Optional[int]:
+        user = message.from_user
+        if not user:
+            return None
+        user_id = user.id
+        if not await self.can_warn(user_id):
+            remaining = await self.get_time_until_next_warning(user_id)
+            logger.info("Not sending warning to %s, cooldown %s", user_id, remaining)
+            return None
+
+        username = f"@{user.username}" if user.username else html.escape(user.full_name)
+        text = (
+            f"–ü–æ—Ö–æ–∂–µ {username}, –≤—ã –ø–∏—à–µ—Ç–µ –≤ –æ–±—â–µ–º —á–∞—Ç–µ, —Ç–æ–≥–¥–∞ –∫–∞–∫ –í–∞—à –æ—Ç–≤–µ—Ç "
+            f"–¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞–ø–∏—Å–∞–Ω –∫–∞–∫ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –ø–æ–¥ –ø–æ—Å—Ç–æ–º.\n\n"
+            "–ü–µ—Ä–µ–Ω–µ—Å–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –ø–æ–¥ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º –ø–æ—Å—Ç–æ–º."
+        )
+        try:
+            sent = await bot.send_message(chat_id=message.chat.id, text=text, reply_to_message_id=message.message_id, parse_mode="HTML")
+            await self.record_warning(user_id)
+            logger.info("Warning sent to %s", user_id)
+            return sent.message_id
+        except Exception:
+            logger.exception("Failed to send warning")
+            return None
+
+    async def format_stats(self) -> str:
+        if not self._cache:
+            await self._load_cache()
+        if not self._cache:
+            return "üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π</b>\n\n–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π –ø–æ–∫–∞ –Ω–µ –±—ã–ª–æ."
+        lines = ["üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π</b>\n"]
+        now = int(datetime.now(timezone.utc).timestamp())
+        for user_id, ts in sorted(self._cache.items(), key=lambda x: x[1], reverse=True):
+            elapsed = now - ts
+            if elapsed < 60:
+                time_str = f"{int(elapsed)}—Å –Ω–∞–∑–∞–¥"
+            elif elapsed < 3600:
+                time_str = f"{int(elapsed // 60)}–º –Ω–∞–∑–∞–¥"
+            else:
+                time_str = f"{int(elapsed // 3600)}—á –Ω–∞–∑–∞–¥"
+            remaining = self.cooldown_seconds - elapsed
+            status = f"‚è≥ {remaining}s" if remaining > 0 else "‚úÖ –¥–æ—Å—Ç—É–ø–Ω–æ"
+            lines.append(f"üë§ ID <code>{user_id}</code>: {time_str} [{status}]")
+        lines.append(f"\n‚è± Cooldown: {self.cooldown_seconds}s")
+        return "\n".join(lines)
+
--- /dev/null
+++ b/notifier.py
@@ -0,0 +1,86 @@
+import html
+import logging
+from aiogram import Bot
+from aiogram.types import Message
+
+logger = logging.getLogger(__name__)
+
+
+class NotificationService:
+    def __init__(self, bot: Bot, admin_id: int, group_id: int):
+        self.bot = bot
+        self.admin_id = admin_id
+        self.group_id = group_id
+
+    async def send_startup(self):
+        try:
+            await self.bot.send_message(
+                self.admin_id,
+                "üü¢ <b>–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω</b>\n\n–ù–∞—á–∞—Ç –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Å–æ–æ–±—â–µ–Ω–∏–π –≤–Ω–µ –≤–µ—Ç–æ–∫ –æ–±—Å—É–∂–¥–µ–Ω–∏—è –∫–∞–Ω–∞–ª–∞.",
+                parse_mode="HTML",
+            )
+        except Exception:
+            logger.exception("Failed to send startup notification")
+
+    async def send_shutdown(self):
+        try:
+            await self.bot.send_message(self.admin_id, "üî¥ <b>–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω</b>", parse_mode="HTML")
+        except Exception:
+            logger.exception("Failed to send shutdown notification")
+
+    async def notify_off_topic_message(self, message: Message):
+        user = message.from_user
+        text = (message.text or message.caption or "").strip()
+        chat_id_str = str(self.group_id)
+        clean_id = chat_id_str[4:] if chat_id_str.startswith("-100") else chat_id_str
+        message_link = f"https://t.me/c/{clean_id}/{message.message_id}"
+        name = html.escape(user.full_name) if user else "Unknown"
+        notification = (
+            "‚ö†Ô∏è <b>–°–æ–æ–±—â–µ–Ω–∏–µ –≤–Ω–µ –≤–µ—Ç–∫–∏ –æ–±—Å—É–∂–¥–µ–Ω–∏—è</b>\n\n"
+            f"üë§ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:</b> {name}"
+        )
+        if user and user.username:
+            notification += f" (@{html.escape(user.username)})"
+        safe_text = html.escape(text[:200]) if text else "‚ö†Ô∏è –ú–µ–¥–∏–∞ –±–µ–∑ —Ç–µ–∫—Å—Ç–∞"
+        notification += (
+            f"\nüí¨ <b>–¢–µ–∫—Å—Ç:</b> {safe_text}"
+            f"{'...' if len(text) > 200 else ''}\n"
+            f"üîó <b>–°—Å—ã–ª–∫–∞:</b> <a href='{message_link}'>–°–æ–æ–±—â–µ–Ω–∏–µ #{message.message_id}</a>"
+        )
+        try:
+            await self.bot.send_message(self.admin_id, notification, parse_mode="HTML", disable_web_page_preview=True)
+        except Exception:
+            logger.exception("Failed to send admin notification")
+
--- /dev/null
+++ b/requirements.txt
@@ -0,0 +1,10 @@
+aiogram==3.0.0b7
+pydantic==1.10.12
+python-dotenv==1.0.0
+aiosqlite==0.18.0
+pytest==7.4.0
+pytest-asyncio==0.21.0
+black==24.3.0
+isort==5.12.0
+
--- /dev/null
+++ b/README.md
@@ -0,0 +1,120 @@
+# tgbot_delete_noncomment (refactor)
+
+–≠—Ç–æ—Ç —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π ‚Äî –±–æ—Ç –¥–ª—è Telegram, –∫–æ—Ç–æ—Ä—ã–π –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–¥–∞–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –≥—Ä—É–ø–ø–µ, –µ—Å–ª–∏ –æ–Ω–∏ –Ω–µ —è–≤–ª—è—é—Ç—Å—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏ –ø–æ–¥ –ø–æ—Å—Ç–∞–º–∏ –∫–∞–Ω–∞–ª–∞.
+
+–í —ç—Ç–æ–º –Ω–∞–±–æ—Ä–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π –¥–æ–±–∞–≤–ª–µ–Ω—ã:
+- pydantic-based –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (Settings)
+- –ü–µ—Ä–µ–Ω–æ—Å –ª–æ–≥–∏–∫–∏ –≤ –º–æ–¥—É–ª–∏ (analyzer, notifier, warning_manager, db)
+- –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–π –≤ SQLite (aiosqlite)
+- –¢–µ—Å—Ç—ã (pytest, pytest-asyncio)
+- CI (GitHub Actions), Dockerfile, systemd example
+- –£–ª—É—á—à–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∏ graceful shutdown
+
+–ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç
+1. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ `.env.example` –≤ `.env` –∏ –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏—è.
+2. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:
+   pip install -r requirements.txt
+3. –ó–∞–ø—É—Å—Ç–∏—Ç–µ:
+   python bot.py
+
+Docker
+1. –°–æ–±–µ—Ä–∏—Ç–µ:
+   docker build -t tgbot_delete_noncomment:latest .
+2. –ó–∞–ø—É—Å—Ç–∏—Ç–µ (–ø—Ä–∏–º–µ—Ä):
+   docker run --env-file .env tgbot_delete_noncomment:latest
+
+CI
+- GitHub Actions –∑–∞–ø—É—Å–∫–∞–µ—Ç —Ç–µ—Å—Ç—ã –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.
+
+–¢–µ—Å—Ç—ã
+- –ó–∞–ø—É—Å–∫: `pytest`
+
+–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
+- –§–∞–π–ª `.env` (–∏–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è) –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏. –°–º. `.env.example`.
+
+–ü—Ä–∏–º–µ—á–∞–Ω–∏—è
+- –î–ª—è production —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è —Ö—Ä–∞–Ω–∏—Ç—å —Ç–æ–∫–µ–Ω –∏ IDs –∫–∞–∫ Secrets –≤ CI / —Å—Ä–µ–¥–µ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è.
+- –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ Redis –≤–º–µ—Å—Ç–æ SQLite, –∑–∞–º–µ–Ω–∏—Ç–µ —Å–ª–æ–π `db.py` –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ –≤—ã–∑–æ–≤—ã.
+
--- /dev/null
+++ b/.env.example
@@ -0,0 +1,25 @@
+# Telegram bot token
+BOT_TOKEN=123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11
+
+# Admin user ID (integer)
+ADMIN_ID=123456789
+
+# Group and channel IDs (integers). Group example: -1001234567890
+GROUP_ID=-1001234567890
+CHANNEL_ID=-1009876543210
+
+# Optional
+AUTO_DELETE_DELAY=10
+WARNING_COOLDOWN=180
+ADMIN_CACHE_TTL_MINUTES=600
+MAX_CHAIN_DEPTH=20
+
+# DB path (sqlite)
+DB_PATH=data/bot.sqlite3
+
--- /dev/null
+++ b/.github/workflows/ci.yml
@@ -0,0 +1,52 @@
+name: CI
+
+on:
+  push:
+    branches:
+      - main
+      - improve/*
+  pull_request:
+    branches:
+      - main
+
+jobs:
+  test:
+    runs-on: ubuntu-latest
+    strategy:
+      matrix:
+        python-version: [3.10, 3.11]
+
+    steps:
+      - uses: actions/checkout@v4
+      - name: Set up Python
+        uses: actions/setup-python@v4
+        with:
+          python-version: ${{ matrix.python-version }}
+
+      - name: Install dependencies
+        run: |
+          python -m pip install --upgrade pip
+          pip install -r requirements.txt
+
+      - name: Lint / format check (black)
+        run: |
+          black --check .
+
+      - name: isort check
+        run: |
+          isort --check-only .
+
+      - name: Run tests
+        env:
+          # Provide dummy env to satisfy pydantic
+          BOT_TOKEN: test
+          ADMIN_ID: "1"
+          GROUP_ID: "1"
+          CHANNEL_ID: "1"
+        run: |
+          pytest -q
+
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,18 @@
+# name=Dockerfile
+FROM python:3.11-slim
+
+ENV PYTHONUNBUFFERED=1
+WORKDIR /app
+
+COPY requirements.txt .
+RUN pip install --no-cache-dir -r requirements.txt
+
+COPY . .
+
+VOLUME /app/data
+
+CMD ["python", "bot.py"]
+
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,10 @@
+__pycache__/
+*.py[cod]
+.env
+data/
+.vscode/
+.idea/
+*.sqlite3
+
--- /dev/null
+++ b/docs/systemd/tgbot.service.example
@@ -0,0 +1,12 @@
+[Unit]
+Description=Telegram discussion monitor bot
+After=network.target
+
+[Service]
+Type=simple
+User=youruser
+WorkingDirectory=/path/to/repo
+ExecStart=/usr/bin/python /path/to/repo/bot.py
+Restart=on-failure
+EnvironmentFile=/path/to/repo/.env
+
+[Install]
+WantedBy=multi-user.target
+
--- /dev/null
+++ b/tests/test_analyzer.py
@@ -0,0 +1,58 @@
+import pytest
+import asyncio
+from types import SimpleNamespace
+
+from analyzer import MessageAnalyzer
+from settings import Settings
+
+
+class DummyMessage(SimpleNamespace):
+    pass
+
+
+@pytest.mark.asyncio
+async def test_is_channel_post_by_sender_chat(tmp_path):
+    s = Settings(
+        BOT_TOKEN="x", ADMIN_ID=1, GROUP_ID=1, CHANNEL_ID=999, _env_file=None
+    )
+    analyzer = MessageAnalyzer(s)
+    msg = DummyMessage(message_id=1, sender_chat=SimpleNamespace(id=999), from_user=None)
+    assert analyzer.is_channel_post(msg) is True
+
+
+@pytest.mark.asyncio
+async def test_is_in_thread_via_reply_chain():
+    s = Settings(
+        BOT_TOKEN="x", ADMIN_ID=1, GROUP_ID=1, CHANNEL_ID=999, _env_file=None
+    )
+    analyzer = MessageAnalyzer(s)
+
+    # chain: msg3 -> reply to msg2 -> reply to msg1 (which is channel post)
+    msg1 = DummyMessage(message_id=1, sender_chat=SimpleNamespace(id=999), from_user=None)
+    msg2 = DummyMessage(message_id=2, reply_to_message=msg1, from_user=SimpleNamespace(id=10))
+    msg3 = DummyMessage(message_id=3, reply_to_message=msg2, from_user=SimpleNamespace(id=11))
+
+    assert await analyzer.is_in_discussion_thread(msg3) is True
+
+
+@pytest.mark.asyncio
+async def test_not_in_thread():
+    s = Settings(
+        BOT_TOKEN="x", ADMIN_ID=1, GROUP_ID=1, CHANNEL_ID=999, _env_file=None
+    )
+    analyzer = MessageAnalyzer(s)
+    msg = DummyMessage(message_id=10, from_user=SimpleNamespace(id=20))
+    assert await analyzer.is_in_discussion_thread(msg) is False
+
--- /dev/null
+++ b/tests/test_warning_manager.py
@@ -0,0 +1,114 @@
+import pytest
+import asyncio
+import os
+from types import SimpleNamespace
+from datetime import datetime, timezone, timedelta
+
+from warning_manager import WarningManager
+from db import init_db, get_last_warning, set_last_warning
+
+DB_TEST = "data/test_bot.sqlite3"
+
+
+@pytest.mark.asyncio
+async def setup_db(tmp_path):
+    dbp = tmp_path / "test_bot.sqlite3"
+    await init_db(str(dbp))
+    return str(dbp)
+
+
+@pytest.mark.asyncio
+async def test_cooldown_and_record(tmp_path):
+    dbp = str(tmp_path / "wtest.sqlite3")
+    await init_db(dbp)
+    wm = WarningManager(cooldown_seconds=2, db_path=dbp)
+
+    user_id = 123
+    # initially can warn
+    assert await wm.can_warn(user_id) is True
+
+    # record warning
+    await wm.record_warning(user_id)
+    assert await get_last_warning(dbp, user_id) is not None
+
+    # immediately cannot warn
+    assert await wm.can_warn(user_id) is False
+
+    # wait for cooldown
+    await asyncio.sleep(2.1)
+    assert await wm.can_warn(user_id) is True
+
+
+@pytest.mark.asyncio
+async def test_send_warning_no_from_user(monkeypatch, tmp_path):
+    dbp = str(tmp_path / "wtest2.sqlite3")
+    await init_db(dbp)
+    wm = WarningManager(cooldown_seconds=1, db_path=dbp)
+
+    class DummyBot:
+        async def send_message(self, chat_id, text, reply_to_message_id=None, parse_mode=None):
+            return SimpleNamespace(message_id=999)
+
+    dummy = DummyBot()
+    msg = SimpleNamespace(from_user=None, chat=SimpleNamespace(id=1), message_id=1)
+    res = await wm.send_warning(dummy, msg)
+    assert res is None
+
-- 
2.34.1